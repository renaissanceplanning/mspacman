library(data.table)
library(ggplot2)
library(gridExtra)
library(magrittr)
library(Matrix)
library(mgcv)
library(pbapply)
library(stringr)

# library(bigrquery) #only used for data acquisition
# library(dplyr) #only use for data acquisition

# Building a complete trips curve ==============================================

#' Calculate a complete trips curve from a set of trip start and end times
#' 
#' @param start_times Vector of trip start times, in integer seconds; should 
#' align with indices of `end_times`
#' @param end_times Vector of trip end times, in integer seconds; should align 
#' with indices of `start times`
#'  
#' @return A vector of completed trips for each minute in a 24 hour day,
#' beginning and ending at 12:00am (for a total of 1441 entries)
completed_trips_by_minute = function(start_times, end_times){
  # Check to ensure start and end times are the same length, and constitute
  # valid trip definitions
  if(any(start_times < 0 | start_times > 86400)){
    stop("all `start_times` must be between 0 and 86400 (inclusive)")
  }
  if(any(end_times < 0 | end_times > 86400)){
    stop("all `end_times` must be between 0 and 86400 (inclusive)")
  }
  if(length(start_times) != length(end_times)){
    stop("`start_times` and `end_times` must be the same length")
  }
  # Count number of trips
  ntrips = length(start_times)
  # Iterate over trips to create trip completion paths
  ijx = purrr::map2(start_times, end_times, function(s,e){
    #print(r)
    # If the trip ends after the day, extend it to the next day
    if(e < s){
      e = 86400 + e
    }
    # Identify the first minute in which trip completion is non-zero, and the
    # last minute in which trip completion is non-1
    smin = ceiling(s/60)
    emin = floor(e/60)
    # Create the trip completion paths
    if(emin > 1440){
      # Trip ends after the first minute of the next day: trip is <1 completed
      # in morning, 1 completed after, then 1+fractional completed in the
      # evening when it starts
      x_add_evening = ((smin:1440)*60-s)/(e - s) + 1
      x_add_morning = ((1441:emin)*60-s)/(e - s)
      i_add = 1:1440
      x_add = c(x_add_morning, 
                rep(1,1440-length(x_add_evening)-length(x_add_morning)),
                x_add_evening)
    } else if(emin == 1440){
      # Trip ends during the first minute of the next day: trip is 1 completed
      # all day, then 1+fractional completed in the evening when it starts
      x_add_evening = ((smin:1440)*60-s)/(e - s) + 1
      i_add = 1:1440
      x_add = c(rep(1,1440-length(x_add_evening)),
                x_add_evening)
    } else{
      # Trip is completed during the day
      i_add = smin:1440
      if(emin > smin){
        # Trip begins and ends in non-consecutive minutes: trip is 0 completed 
        # before it starts, fractional completed while it is going, then 1 
        # completed once it is over
        x_add = c(c((smin:emin*60-s)/(e - s)), rep(1, length((emin+1):1440)))
      } else if(emin == smin){
        # Trip begins in one minute and ends in the next: trip is 0 completed
        # before the end, 1 completed after
        x_add = rep(1, length(emin:1440))
      } else{
        # Trip begins and ends in same minute: trip is 0 completed before
        # starting, 1 complete upon starting
        x_add = rep(1, length(smin:1440))
      }
      if(smin == 0){
        i_add = i_add[2:length(i_add)]
        x_add = x_add[2:length(x_add)]
      }
    }
    # if(length(i_add) != length(x_add)){
    #   break
    # }
    # Adjust for time=0 -- that's whatever you've got at 1440 - 1
    w = which(i_add == 1440)
    if(x_add[w] > 1){
      x_add = c(x_add[w] - 1, x_add)
      i_add = c(1, i_add+1)
    } else{
      i_add = i_add+1
    }
    j_add = rep(r, length(i_add))
    return(list(i=i_add, j=j_add, x=x_add))
  })
  # Create a sparse matrix defining the trip completion paths
  M = sparseMatrix(i=lapply(ijx, function(l){l$i}) %>% unlist(),
                   j=lapply(ijx, function(l){l$j}) %>% unlist(),
                   x=lapply(ijx, function(l){l$x}) %>% unlist(),
                   dims=c(1441,ntrips))
  # Row sums of the matrix are the total completed trips at each minute
  complete_trips = rowSums(M)
  return(complete_trips)
}

# Combine complete trips counts ================================================

#' Combine multiple completed trips by minute vectors into a single vector
#' 
#' This function combines any number of complete trip by minute vectors into a 
#' single completed trips by minute vector by adding completed trips at each 
#' minute
combine_completed_trips_by_minute = function(...){
  lens = lapply(..., length) %>% unlist()
  dtypes = lapply(..., is.numeric) %>% unlist()
  if(!all(lens == 1441) | any(!dtypes)){
    stop("at least 1 input is not a valid complete trips by minute vector")
  }
  ctc = Reduce(cbind, ...) %>%
    rowSums()
  return(ctc)
}

# Smoothing function for complete trips ========================================

#' Convert a completed trips by minute vector into a completed trips curve
#' 
#' @param x A completed trips by minute vector
#' @param percent A boolean indicating whether the curve should be constructed
#' as total trips completed (FALSE) or share of trips completed (TRUE). Setting
#' `percent=TRUE` allows direct comparisons to be made across groupings that 
#' have different magnitudes of completed trips
#' 
#' @return A function defining the completed trips curve for the input completed
#' trips by minute. It will span a 2-day period to guarantee continuity at
#' 12:00am
complete_trips_curve = function(x, percent=FALSE){
  # Stretch the curve over 2 days for continuity at midnight
  if(length(x) != 1441 | !is.numeric(x)){
    stop("`x` is not a valid complete trips curve")
  }
  day1 = data.table(x=0:1440,
                    y=x)
  if(percent==TRUE){
    day1$y = (day1$y - min(day1$y)) / (max(day1$y) - min(day1$y))
  }
  day2 = data.table(x=1441:2880,
                    y=(day1$y[nrow(day1)]-day1$y[1])+day1$y[2:nrow(day1)])
  curve = rbind(day1, day2)
  # Fit and return the smooth function
  s = splinefun(x=curve$x, y=curve$y, method="monoH.FC") #hyman?? either will guarantee derivatives >= 0
  return(s)
}

# Productivity (derivative of complete trips curve) ============================

#' Calculate trip productivity
#' 
#' "Productivity" is defined as the first derivative of the complete trips
#' curve at time \eqn{t}
#' 
#' @param times A vector of times specified in minutes (and therefore between
#' 0 and 1440, inclusive)
#' @param complete_trips_curve The complete trips curve on which to assess
#' productivity
#' 
#' @return A vector of productivities for each time in `times`
productivity = function(times, complete_trips_curve){
  # Check times, and convert to 12:00pm-12:00pm to guarantee continuity
  if(any(times < 0 | times > 1440)){
    stop("at least one time in `times` is improperly specified")
  }
  times[times < 720] = times[times < 720] + 720
  # Take productivity as the derivative of the complete trips curve
  pdt = complete_trips_curve(times, deriv=1)
  return(pdt)
}

# Efficiency (expected observed completed trips in interval) ===================

#' Calculate trip efficiency
#' 
#' "Efficiency" is defined as the expected number of completed trips observed
#' (or share of completed trips observed) at a random point in a specified 
#' interval. That is to say, for a random time \eqn{t: t1 <= t <= t2}, how many 
#' completed trips (or what share of total trips completed) would we expect to 
#' have observed?
#' 
#' @param time_lowers Lower bound for time intervals; should align with indices 
#' of `time_uppers`.
#' @param time_uppers Upper bound for time intervals; should align with indices
#' of `time_lowers`
#' @param complete_trips_curve The complete trips curve on which to assess
#' efficiency
#' 
#' @return A vector of efficiencies for each interval implied by `time_lowers`
#' and `time_uppers`
efficiency = function(time_lowers, time_uppers, complete_trips_curve){
  # Take efficiency as expected value of completed trips curve over the interval
  # (treating the initial value as "0" so we get newly completed trips)
  full_integral = purrr::map2(time_lowers, time_uppers, function(l,u){
    integrate(complete_trips_function, l, u)$value
  }) %>% unlist()
  interval_width = time_uppers - time_lowers
  zero_reset = complete_trips_function(time_lowers) * interval_width
  eff = (full_integral - zero_reset) / interval_width
  return(eff)
}

# Plot the complete trips curve ===============================================

#' Plot a complete trips curve
#' 
#' @param complete_trips_curve A complete trips curve
#' 
#' @return a `ggplot2` plot of the complete trips curve
plot_complete_trips_curve = function(complete_trips_curve){
  ctpd = complete_trips_function(1440) - complete_trips_function(0)
  dt = data.table(x=720:2159) %>%
    .[, y := complete_trips_function(x, deriv=0)]
  dt[x > 1440, y := y-ctpd]
  dt[x > 1440, x := x-1440]
  dt = rbind(dt, data.table(x=0, y=dt$y[dt$x==1440]-ctpd))
  ymax = max(dt$y)
  xmax = 1440
  ggplot(data=dt) +
    geom_line(aes(x=x, y=y), color="red") +
    geom_hline(aes(yintercept=0)) +
    geom_vline(aes(xintercept=0)) +
    scale_x_continuous(name="Time (hours)",
                       breaks=seq(0,1440,120),
                       limits=c(0,xmax),
                       labels=seq(0,24,2),
                       expand=c(0.025,0.025)) +
    scale_y_continuous(name="Completed trips",
                       # breaks=seq(0,ymax,2000),
                       limits=c(0,ymax),
                       expand=c(0.025,0.025),
                       labels=scales::comma) +
    labs(title="Raw completed trips")
}

# Plot productivity ============================================================

#' Plot productivity for a complete trips curve
#' 
#' @param complete_trips_curve A complete trips curve
#' @param smooth Should the curve be smoothed using `ggplot::geom_smooth`?
#' 
#' @return a `ggplot2` plot of productivity
plot_productivity = function(complete_trips_curve, smooth=TRUE){
  dt = data.table(x=720:2159) %>%
    .[, y := productivity(x, complete_trips_function)]
  dt[x > 1440, x := x-1440]
  dt = rbind(dt, data.table(x=0, y=dt$y[dt$x==1440]))
  ymax = max(dt$y)
  xmax = 1440
  gg = ggplot(data=dt) +
    geom_line(aes(x=x, y=y), color="red") +
    geom_hline(aes(yintercept=0)) +
    geom_vline(aes(xintercept=0)) +
    scale_x_continuous(name="Time (hours)",
                       breaks=seq(0,1440,120),
                       limits=c(0,xmax),
                       labels=seq(0,24,2),
                       expand=c(0.025,0.025)) +
    scale_y_continuous(name="Productivity",
                       # breaks=0:ymax,
                       limits=c(0,ymax),
                       expand=c(0.025,0.025)) +
    labs(title="Productivity")
  if(smooth==TRUE){
    gg + geom_smooth(aes(x=x, y=y))
  } else{
    gg
  }
}

# Plot efficiency ==============================================================

#' Plot efficiency for a complete trips curve
#' 
#' @param complete_trips_curve A complete trips curve
#' @param window The size of the window (in minutes) over which efficiency
#' should be calculated
#' @param smooth Should the curve be smoothed using `ggplot::geom_smooth`?
#' 
#' @return a `ggplot2` plot of efficiency
plot_efficiency = function(complete_trips_function, window=1, smooth=TRUE){
  dt = data.table(x=720:2159) %>%
    .[, y := efficiency(x-window/2, x+window/2, complete_trips_function)]
  dt[x > 1440, x := x-1440]
  dt = rbind(dt, data.table(x=0, y=dt$y[dt$x==1440]))
  ymax = max(dt$y)
  xmax = 1440
  gg = ggplot(data=dt) +
    geom_line(aes(x=x, y=y), color="red") +
    geom_hline(aes(yintercept=0)) +
    geom_vline(aes(xintercept=0)) +
    scale_x_continuous(name="Time (hours)",
                       breaks=seq(0,1440,120),
                       limits=c(0,xmax),
                       labels=seq(0,24,2),
                       expand=c(0.025,0.025)) +
    scale_y_continuous(name="Average observed completed trips in window",
                       # breaks=0:ymax,
                       limits=c(0,ymax),
                       expand=c(0.025,0.025))
    labs(title=paste0("Efficiency (within ", window, " minute windows)"))
  if(smooth==TRUE){
    gg + geom_smooth(aes(x=x, y=y))
  } else{
    gg
  }
}

# Example ======================================================================

# TODO: do this by destination

# Testing area -- Orange County, FL
orange_bg=tigris::block_groups(state="FL", county="Orange", year=2019) %>%
  dplyr::select(GEOID)
query_bg = orange_bg$GEOID

# # Authenticate BQ account
# bq_auth(scopes = "https://www.googleapis.com/auth/bigquery")
# 
# # Connect to the BigQuery northwest 2021 trips table
# con = dbConnect(
#   bigquery(),
#   project = "replica-customer",
#   dataset = "south_atlantic"
# )
# dbListTables(con)
# trip_con = tbl(con, "south_atlantic_2021_Q2_thursday_trip")
# 
# # Grab the start and end time for all trips originating in our zone
# query_bg = orange_bg$GEOID
# se = trip_con %>%
#   filter(origin_bgrp %in% query_bg) %>%
#   select(origin_bgrp, start_time, end_time) %>%
#   collect() %>%
#   data.table() %>%
#   .[, start_time := as.numeric(start_time)] %>%
#   .[, end_time := as.numeric(end_time)] %>%
#   .[order(origin_bgrp, start_time)]
# # saveRDS(se, "C:/Users/w_rpg/Downloads/orange_county_se.rds")

# Replica data for Orange County
se = readRDS("C:/Users/w_rpg/Downloads/orange_county_se.rds")

# For each bg, build a complete trips curve
ctc = pblapply(query_bg, function(x){
  print(x)
  df = se[origin_bgrp == x]
  if(nrow(df) > 0){
    calculate_complete_trips_curve(df=df, start_time="start_time", 
                                   end_time="end_time")
  } else{
    rep(0, 1441)
  }
})
M = purrr::reduce(ctc, cbind)
colnames(M) = query_bg
# saveRDS(M, "C:/Users/w_rpg/Downloads/orange_county_ctc_matrix.rds")

# Functionalize
# Note that "120959900000" is all 0s
ctc_funs_raw = pbapply(M[,colnames(M)!="120959900000"], 2, 
                       functionalize_complete_trips_curve)
ctc_funs_perc = pbapply(M[,colnames(M)!="120959900000"], 2, 
                        functionalize_complete_trips_curve, percent=TRUE)

# Plot curves for one BG
plot_complete_trips_curve(ctc_funs_raw[[1]])
plot_complete_trips_curve(ctc_funs_perc[[1]])

plot_productivity(ctc_funs_raw[[1]], smooth=FALSE)
plot_productivity(ctc_funs_perc[[1]], smooth=FALSE) + 
  ylim(c(0,0.0025)) +
  scale_y_continuous(labels=scales::percent_format(0.01))

plot_efficiency(ctc_funs_raw[[201]], window=10, smooth=FALSE)
plot_efficiency(ctc_funs_perc[[201]], window=10, smooth=FALSE) + 
  ylim(c(0,0.0125)) + 
  scale_y_continuous(labels=scales::percent_format(0.01))

# Map efficiencies at various times
times = c(1980, 720, 2460, 2490)
time_lowers = times-5
time_uppers = times+5
eff_raw = pblapply(ctc_funs_raw, function(x){
  efficiency(time_lowers, time_uppers, x) %>%
    t() %>%
    data.table() %>%
    setnames(c("t9am","t12pm","t5pm","t530pm"))
}) %>%
  rbindlist() %>%
  .[, GEOID := names(ctc_funs_raw)]
eff_perc = pblapply(ctc_funs_perc, function(x){
  efficiency(time_lowers, time_uppers, x) %>%
    t() %>%
    data.table() %>%
    setnames(c("t9am","t12pm","t5pm","t530pm"))
}) %>%
  rbindlist() %>%
  .[, GEOID := names(ctc_funs_perc)]
eff_map_raw = inner_join(orange_bg, eff_raw, by="GEOID") %>%
  sf::st_transform(4326)
eff_map_perc = inner_join(orange_bg, eff_perc, by="GEOID") %>%
  sf::st_transform(4326)
pal_raw = colorBin(palette="viridis",
                   bins=c(0,10,20,30,40,50,100,150,200,Inf))
pal_perc = colorBin(palette="viridis",
                    bins=c(0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.01,Inf))

MAP_TIME = "530pm" #"12pm", "5pm"
map_var = if(MAP_TIME == "9am"){
  "t9am"
}else if(MAP_TIME == "12pm"){
  "t12pm"
}else if(MAP_TIME == "530pm"){
  "t530pm"
}else{
  "t5pm"
}
leaflet(eff_map_raw) %>%
  addProviderTiles("Esri.WorldStreetMap") %>%
  addPolygons(weight=0.5, 
              color="black",
              fillColor=~pal_raw(eff_map_raw[[map_var]]), 
              fillOpacity=0.75,
              popup=~GEOID) %>%
  addLegend("bottomleft", 
            pal=pal_raw, 
            values=~eff_map_raw[[map_var]],
            title="Trip efficiency",
            opacity=1) %>%
  addControl(htmltools::HTML(paste("Origin zone trip efficiency in a",
                                   "10 minute window around", MAP_TIME)),
             position="topright")
leaflet(eff_map_perc) %>%
  addProviderTiles("Esri.WorldStreetMap") %>%
  addPolygons(weight=0.5, 
              color="black",
              fillColor=~pal_perc(eff_map_perc[[map_var]]), 
              fillOpacity=0.75,
              popup=~GEOID) %>%
  addLegend("bottomleft", 
            pal=pal_perc, 
            values=~eff_map_perc[[map_var]],
            title="Trip efficiency",
            opacity=1) %>%
  addControl(htmltools::HTML(paste("Origin zone trip efficiency in a",
                                   "10 minute window around", MAP_TIME)),
             position="topright")


leaflet(eff_map_raw %>% filter(GEOID=="120950147031")) %>%
  addProviderTiles("Esri.WorldStreetMap") %>%
  addPolygons()

