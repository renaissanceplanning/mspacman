---
title: "An approach to time-continuous productivity"
author: "Aaron Weinstock (Renaissance Planning)"
date: "July 20, 2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE, warning=FALSE, message=FALSE)
```

```{r Libraries and globals}
# Uncomment and install as necessary if packages below don't load
# install.packages("data.table")
# install.packages("ggplot2")
# install.packages("gridExtra")
# install.packages("magrittr")
# install.packages("Matrix")
# install.packages("mgcv")
# install.packages("pbapply")
# install.packages("stringr")
library(data.table)
library(ggplot2)
library(gridExtra)
library(magrittr)
library(Matrix)
library(mgcv)
library(pbapply)
library(stringr)
# library(bigrquery) #only used for data acquisition
# library(dplyr) #only use for data acquisition

# Data directory
DATA = "C:/Users/w_rpg/Downloads/continuous_productivity" 
# Set this wherever you unzip the associated .rds file (that's the only
# thing we need this directory for)
```

```{r Data acquisition}
# Block group for testing -- go beavs
# benton_bg="https://lehd.ces.census.gov/data/lodes/LODES7/or/or_xwalk.csv.gz" %>%
#   fread() %>%
#   .[, bgrp] %>%
#   .[str_detect(., "^41003")] %>%
#   as.character()
# 
# # Authenticate BQ account
# bq_auth(scopes = "https://www.googleapis.com/auth/bigquery")
# 
# # Connect to the BigQuery northwest 2021 trips table
# con = dbConnect(
#   bigquery(),
#   project = "replica-customer",
#   dataset = "northwest"
# )
# dbListTables(con)
# trip_con = tbl(con, "northwest_2021_Q2_thursday_trip")
# 
# # Grab the start and end time for all trips originating in our zone
# se = trip_con %>%
#   #filter(origin_bgrp==chintimini) %>%
#   filter(origin_bgrp %in% benton_bg) %>%
#   select(origin_bgrp, start_time, end_time) %>%
#   collect() %>%
#   data.table() %>%
#   .[, start_time := as.numeric(start_time)] %>%
#   .[, end_time := as.numeric(end_time)] %>%
#   .[order(origin_bgrp, start_time)]
```

```{r Analysis}
# Data
se = file.path(DATA, "continuous_productivity_data_benton.rds") %>%
  readRDS()

# Set up a matrix to track completed trips by minute over the course of the day.
# The rows will be minutes; the columns will be trips. The "completeness" of the
# trip is judged by how much of the trip has been completed by the beginning of
# that minute (e.g. a 2 minute trip that begins at 15.5 mins and ends at 17.5
# mins is 0% complete at 15, 25% complete at 16, 75% complete at 17, and 100%
# complete from 18 on). In this way, row sums across this matrix will give us
# the number of completed trips by minute.
# We iterate over the zones in our trip table such that our final output is
# a matrix of size [minutes/day, number of zones in trip table], where the
# [i,j] entry is the number of trips originating in zone j that have been
# completed by time i.
u_bgs = se$origin_bgrp %>% unique()
M = pblapply(u_bgs, function(geoid){
  # print(geoid)
  df = se[origin_bgrp == geoid]
  ntrips = nrow(df)
  ijx = lapply(1:ntrips, function(r){
    # print(r)
    s = df$start_time[r]
    e = df$end_time[r]
    if(e < s){
      e = 86400 + e
    }
    smin = ceiling(s/60)
    emin = floor(e/60)
    if(emin > 1440){
      x_add_evening = ((smin:1440)*60-s)/(e - s) + 1
      x_add_morning = ((1441:emin)*60-s)/(e - s)
      i_add = 1:1440
      x_add = c(x_add_morning, 
                rep(1,1440-length(x_add_evening)-length(x_add_morning)),
                x_add_evening)
    } else if(emin == 1440){
      x_add_evening = ((smin:1440)*60-s)/(e - s) + 1
      i_add = 1:1440
      x_add = c(rep(1,1440-length(x_add_evening)),
                x_add_evening)
    } else{
      i_add = smin:1440
      if(emin > smin){
        x_add = c(c((smin:emin*60-s)/(e - s)), rep(1, length((emin+1):1440)))
      } else if(emin == smin){
        x_add = rep(1, length(emin:1440))
      } else{
        x_add = rep(1, length(smin:1440))
      }
    }
    if(length(i_add) != length(x_add)){
      break
    }
    j_add = rep(r, length(i_add))
    return(list(i=i_add, j=j_add, x=x_add))
  })
  Mgeoid = sparseMatrix(i=lapply(ijx, function(l){l$i}) %>% unlist(),
                        j=lapply(ijx, function(l){l$j}) %>% unlist(),
                        x=lapply(ijx, function(l){l$x}) %>% unlist(),
                        dims=c(1440,ntrips))
  rowSums(Mgeoid)
}) %>%
  purrr::reduce(., cbind)
colnames(M) = u_bgs

# Create a table of completed trips, and plot.
# We'll use the Chintimini block group as an example
chintimini = "410030011011"
ct = data.table(x = 1:1440,
                y = M[,chintimini])
plot_completed_trips = ggplot(data=ct) +
  geom_line(aes(x=x, y=y), color="red") +
  geom_hline(aes(yintercept=0)) +
  geom_vline(aes(xintercept=0)) +
  scale_x_continuous(name="Time (hours)",
                     breaks=seq(0,1440,60),
                     labels=0:24,
                     expand=c(0.025,0.025)) +
  scale_y_continuous(name="Completed trips",
                     breaks=seq(0,2500,100),
                     expand=c(0.025,0.025),
                     limits=c(0,2500)) +
  labs(title="Raw completed trips leaving the origin zone on a Thursday")

# Create a table of productivity, and plot. Productivity here is the derivative
# of the completed trips curve; it gives us the instantaneous rate of increase
# in completed trips at any given minute. Completed trips is monotonically
# increasing with time, so our productivity will always be positive, but will
# be higher at some points in the day than others
dydx_ct = data.table(x = rowMeans(embed(ct$x,2)),
                     y = diff(ct$y)/diff(ct$x))
plot_productivity = ggplot(data=dydx_ct) +
  geom_line(aes(x=x, y=y), color="red") +
  geom_hline(aes(yintercept=0)) +
  geom_vline(aes(xintercept=0)) +
  scale_x_continuous(name="Time (hours)",
                     breaks=seq(0,1440,60),
                     labels=0:24,
                     expand=c(0.025,0.025)) +
  scale_y_continuous(name="Productivity (completed trips per minute)",
                     breaks=seq(0,8.5,0.5),
                     expand=c(0.025,0.025),
                     limits=c(0,8.5)) +
  labs(title="Raw productivity over the course of the day for trips leaving the origin zone")

# Note that we can guarantee equal productivity at matching times by repeating
# our data over two days. In this way, we should see no "edge effects" 
# associated with start/end at midnight, and can instead complete our analysis
# from noon-to-noon, allowing us access to full information about trip
# completion "before and after" our day. As so:
# ct = data.table(x = 1:(1440*2),
#                   y = c(M[,chintimini], M[,chintimini]+max(M[,chintimini])))
# dydx_ct = data.table(x = rowMeans(embed(ct$x,2)),
#                      y = diff(ct$y)/diff(ct$x))
# For proof, observe the difference in derivative at equal times. We can iterate
# over all block groups and see that this is the case
lapply(u_bgs, function(geoid){
  ct = data.table(x = 1:(1440*2),
                  y = c(M[,geoid], M[,geoid]+max(M[,geoid])))
  dydx_ct = data.table(x = rowMeans(embed(ct$x,2)),
                       y = diff(ct$y)/diff(ct$x))
  dydx_ct[x > 1440, x := x-1440]
  dydx_ct[, .(u=diff(y)), by=x]$u %>% abs() %>% max()
}) %>% 
  unlist() %>% 
  quantile()
```

```{r Plot, fig.dim = c(12, 6)}
# Show completed trips and productivity side by side
grid.arrange(plot_completed_trips,
             plot_productivity,
             nrow=1)
```

```{r Smoothing, fig.dim = c(12, 6)}
# smooth = gam(y ~ s(x, bs = "cs"), data=ct)
# smooth_ct = data.table(x=ct$x,
#                        y=predict(smooth))
# smooth_dydx_ct = data.table(x = rowMeans(embed(smooth_ct$x,2)),
#                             y = diff(smooth_ct$y)/diff(smooth_ct$x))
k = 15
unc <- gam(y ~ s(x, k=k, bs = "cr"), data = ct)
sm <- smoothCon(s(x, k=k, bs = "cr"), ct, knots = NULL)[[1]]
F <- mono.con(sm$xp, up=TRUE)
G <- list(X = sm$X, C = matrix(0,0,0), sp = unc$sp,
          p = sm$xp,
          y = ct$y,
          w = ct$y*0+1)
G$Ain <- F$A
G$bin <- F$b
G$S <- sm$S
G$off <- 0 
p <- pcls(G)
fv <- Predict.matrix(sm, data.frame(x=ct$x)) %*% p
min(fv)
smooth_ct = data.table(x=ct$x,
                       y=fv %>% as.vector())
smooth_dydx_ct = data.table(x = rowMeans(embed(smooth_ct$x,2)),
                            y = diff(smooth_ct$y)/diff(smooth_ct$x))
plot_smooth_completed_trips = ggplot(data=smooth_ct) +
  geom_line(aes(x=x, y=y), color="red") +
  geom_hline(aes(yintercept=0)) +
  geom_vline(aes(xintercept=0)) +
  scale_x_continuous(name="Time (hours)",
                     breaks=seq(0,1440,60),
                     labels=0:24,
                     expand=c(0.025,0.025)) +
  scale_y_continuous(name="Completed trips",
                     breaks=seq(0,2500,100),
                     expand=c(0.025,0.025),
                     limits=c(0,2500)) +
  labs(title="Smoothed completed trips leaving the origin zone on a Thursday")
plot_smooth_productivity = ggplot(data=smooth_dydx_ct) +
  geom_line(aes(x=x, y=y), color="red") +
  geom_hline(aes(yintercept=0)) +
  geom_vline(aes(xintercept=0)) +
  scale_x_continuous(name="Time (hours)",
                     breaks=seq(0,1440,60),
                     labels=0:24,
                     expand=c(0.025,0.025)) +
  scale_y_continuous(name="Productivity (completed trips per minute)",
                     breaks=seq(0,8.5,0.5),
                     expand=c(0.025,0.025),
                     limits=c(0,8.5)) +
  labs(title="Smoothed productivity over the course of the day for trips leaving the origin zone")
grid.arrange(plot_smooth_completed_trips,
             plot_smooth_productivity,
             nrow=1)
dydx_ct[x >= 715 & x <= 725] %>%
  ggplot() +
  geom_line(aes(x=x, y=y)) +
  geom_point(aes(x=x, y=y))
data.frame(x=seq(715,725,by=0.001)) %>%
  dplyr::mutate(y=s(x, deriv=1)) %>%
  ggplot() +
  geom_line(aes(x=x, y=y)) +
  geom_point(aes(x=x, y=y))

```

```{r}
# Smoothing the complete trips curve to get continuous differentiability
fit = lapply(colnames(M), function(geoid){
  print(geoid)
  ct = data.table(x = 1:1440,
                  y = M[,geoid])
  dydx_ct = data.table(x = rowMeans(embed(ct$x,2)),
                       y = diff(ct$y)/diff(ct$x))
  methods = c("fmm","natural","monoH.FC","hyman")
  err = lapply(methods, function(m){
    s = splinefun(ct$x, ct$y, m)
    d = s(dydx_ct$x, 1)
    return(list(neg = sum(d < 0),
                #mae = (abs(d-dydx_ct$y) %>% sum()) / nrow(dydx_ct))),
                mae = abs((d-dydx_ct$y)/dydx_ct$y) %>% mean()))
  })
  neg = lapply(err, function(z){z$neg}) %>% unlist() %>% t() %>% data.table() %>% setnames(methods)
  mae = lapply(err, function(z){z$mae}) %>% unlist() %>% t() %>% data.table() %>% setnames(methods)
  return(list(neg=neg, mae=mae))
})
neg = lapply(fit, function(x){x$neg}) %>% rbindlist()
mae = lapply(fit, function(x){x$mae}) %>% rbindlist()
colSums(neg)
colMeans(mae, na.rm=TRUE)
apply(mae, 2, median, na.rm=TRUE)
# Periodic splines don't work because this is an increasing function
# FMM and natural both produce negative derivatives -- not good, bc productivity
# should always be positive
# monoH.FC and hyman both have all positive derivatives, but hyman appears to
# produce lower error relative to a linear estimation
# so, we go with Hyman
# Hyman averages ~3.5% "error" on linearly estimated derivatives at values in
# sequence of 0.5

# Options:
# 1. Apply Hyman spline to complete trips curve, take productivity as dy/dx
# 2. Keep complete trips curve as it, take productivity for x as slope between
#    floor(x) and ceiling(x) + I(is.integer(x))
```

